//
//  MyGoalsScreenPresenter.swift
//  GoalTracker
//
//  Created by Georges on 3/4/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit
import Combine

final class MyGoalsScreenPresenter {

    // MARK: - Private properties -

    private unowned let view: MyGoalsScreenViewInterface
    private let interactor: MyGoalsScreenInteractorInterface
    private let wireframe: MyGoalsScreenWireframeInterface
    private var cancellableSet: Set<AnyCancellable> = Set()
    private var goals: [Goal] = [] {
        didSet { view.reloadView() }
    }
    private var goalsProgress: [GoalProgress] = [] {
        didSet { view.reloadView() }
    }
    private var isLoading: Bool = false {
        didSet {
            if isLoading {
                self.view.showLoader()
            } else {
                self.view.hideLoader()
            }
        }
    }
    private var didAppearOnce: Bool = false
    
    // MARK: - Lifecycle -

    init(
        view: MyGoalsScreenViewInterface,
        interactor: MyGoalsScreenInteractorInterface,
        wireframe: MyGoalsScreenWireframeInterface
    ) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
    
    func bindToInteractor() {
        interactor
            .goalsPublisher
            .receive(on: DispatchQueue.main)
            .assignNoRetain(to: \.goals, on: self)
            .store(in: &cancellableSet)
        
        interactor
            .goalProgressPublisher
            .receive(on: DispatchQueue.main)
            .assignNoRetain(to: \.goalsProgress, on: self)
            .store(in: &cancellableSet)
        
        interactor
            .refreshStatePublisher
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: { [weak self] (state) in
                guard let self = self else { return }
                switch state {
                case .failed(let error):
                    self.isLoading = false
                    self.handleError(error: error)
                case .refreshing:
                    self.isLoading = true
                case .succeeded:
                    self.isLoading = false
                    self.view.reloadView()
                }
            })
            .store(in: &cancellableSet)
    }
        
    func refreshGoals() {
        view.showLoader()
        interactor.refreshGoals()
    }
    
    func handleError(error: DomainError) {
        view.handleError(error: error)
    }
}

// MARK: - Extensions -

extension MyGoalsScreenPresenter: MyGoalsScreenPresenterInterface {
    
    func viewLoaded() {
        bindToInteractor()
        interactor.setDate(date: World.date)
    }
    
    func viewDidAppear() {
        if !didAppearOnce {
            didAppearOnce = true
            refreshGoals()
        }
    }
    
    func viewWillDisappear() {}
    
    func refresh() {
        self.refreshGoals()
    }
    
    func nextDate() {
        if let nextDate = World.calendar.date(byAdding: .day, value: 1, to: interactor.date) {
            interactor.setDate(date: nextDate)
        }
    }
    
    func previousDate() {
        if let nextDate = World.calendar.date(byAdding: .day, value: -1, to: interactor.date) {
            interactor.setDate(date: nextDate)
        }
    }
    
    var viewTitle: String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .short
        dateFormatter.timeStyle = .none
        return dateFormatter.string(from: interactor.date)
    }
        
    var numberOfGoals: Int {
        goals.count
    }
    
    func goalName(index: Int) -> String {
        goals[index].title
    }
    
    func goalProgress(index: Int) -> Double {
        let goalId = goals[index].id
        if let progress = goalsProgress.first(where: { $0.goalId == goalId }) {
            switch progress.progressState {
            case .inProgress(percentage: let progress):
                return progress
            case .notStarted:
                return 0.0
            case .reached:
                return 1.0
            }
        }
        return 0
    }
    
    func goalSelected(index: Int) {
        let goalId = goals[index].id
        wireframe.routeToGoalDetails(
            date: interactor.date,
            goalFetching: interactor.goalFetching(goalId: goalId),
            progressFetching: interactor.goalProgressFetching(goalId: goalId)
        )
    }
    
}
